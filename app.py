# -*- coding: utf-8 -*-
import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px  # SUGEST√ÉO: Importar Plotly para gr√°ficos interativos
import os
import re

# --- CONFIGURA√á√ÉO DA P√ÅGINA ---
st.set_page_config(
    layout="wide",
    page_title="An√°lise de G√™neros de Filmes/S√©ries",
    page_icon="üé¨"
)

# --- FUN√á√ïES DE PROCESSAMENTO DE DADOS ---

@st.cache_data # Cache para carregar os dados apenas uma vez
def load_data():
    """Carrega os dados j√° pr√©-processados."""
    try:
        df = pd.read_csv('data/processed/data_tratada.csv', encoding='utf-8-sig')
        # N√£o precisa mais de aplicar a limpeza aqui!
        return df
    except Exception as e:
        st.error(f"Erro ao carregar dados: {e}")
        return None

    except Exception as e:
        st.error(f"Ocorreu um erro ao carregar ou processar os dados: {str(e)}")
        return None

def clean_and_standardize_genres(genres_str):
    """
    Padroniza os g√™neros, consolida subg√™neros e remove inconsist√™ncias,
    lidando com m√∫ltiplos separadores e combina√ß√µes espec√≠ficas.
    """
    if pd.isna(genres_str) or not isinstance(genres_str, str):
        return ''

    # Dicion√°rio de mapeamento para padronizar nomes de g√™neros
    genre_mapping = {
        'action adventure': 'action',
        'action-adventure': 'action',
        'sci-fi fantasy': 'science fiction',
        'war politics': 'war',
        'film-noir': 'noir',
        'tv movie': 'movie',
        'sci-fi': 'science fiction',
        'science-fiction': 'science fiction',
        'sci fi': 'science fiction',
        'reality-tv': 'reality',
        'talk-show': 'talk show',
        'game-show': 'game show',
        'musical': 'music'
    }

    # 1. Limpa caracteres de lista e converte para min√∫sculas
    processed_str = str(genres_str).lower().replace('[','').replace(']','').replace("'",'').replace('"','')
    
    # 2. Aplica mapeamentos de frases completas primeiro
    for key, value in genre_mapping.items():
        processed_str = processed_str.replace(key, value)

    # 3. Divide a string em uma lista de g√™neros usando m√∫ltiplos separadores
    genres_list = re.split(r'[,/&;]', processed_str)
    
    # 4. Limpa espa√ßos em branco e remove strings vazias, criando um conjunto para valores √∫nicos
    mapped_genres = {g.strip() for g in genres_list if g.strip()}

    # 5. L√≥gica de consolida√ß√£o para combina√ß√µes espec√≠ficas
    # Se um filme √© 'Action' e 'Adventure', consideramos apenas 'Action'.
    if 'action' in mapped_genres and 'adventure' in mapped_genres:
        mapped_genres.remove('adventure')
    
    # Se um filme √© 'Science Fiction' e 'Fantasy', consideramos apenas 'Science Fiction'.
    if 'science fiction' in mapped_genres and 'fantasy' in mapped_genres:
        mapped_genres.remove('fantasy')

    # 6. Retorna a string final, ordenada e com letras mai√∫sculas
    if not mapped_genres:
        return ''
    return ','.join(sorted([g.title() for g in mapped_genres]))

    # Primeiro, aplicamos o mapeamento para frases completas
    genres_str_lower = str(genres_str).lower()
    for key, value in genre_mapping.items():
        if key in genres_str_lower:
            genres_str_lower = genres_str_lower.replace(key, value)

    # Agora, separamos e limpamos os g√™neros individuais
    genres = [g.strip() for g in genres_str_lower.split(',')]
    
    # Usamos um set para garantir que os g√™neros sejam √∫nicos ap√≥s a limpeza
    cleaned_genres = set()

    for genre in genres:
        # Remove caracteres especiais e espa√ßos extras
        cleaned = re.sub(r'[^\w\s-]', '', genre).strip()
        if cleaned:
            cleaned_genres.add(cleaned)

    # Retorna os g√™neros em ordem alfab√©tica e com a primeira letra mai√∫scula
    return ','.join(sorted([g.title() for g in cleaned_genres]))


def get_unique_genres(df):
    """Extrai uma lista de todos os g√™neros √∫nicos do DataFrame."""
    all_genres = set()
    # O m√©todo explode √© mais eficiente para "desaninhar" listas
    df_exploded = df['genres'].str.split(',').explode()
    all_genres.update([g.strip() for g in df_exploded.dropna() if g.strip()])
    return sorted(list(all_genres))

# --- FUN√á√ïES DE RENDERIZA√á√ÉO DAS ABAS (SUGEST√ÉO: Refatora√ß√£o) ---
# Mover a l√≥gica de cada aba para sua pr√≥pria fun√ß√£o deixa o c√≥digo principal mais limpo.

def render_introduction_tab():
    """Renderiza o conte√∫do da aba de Introdu√ß√£o."""
    st.header("Oi! Vem c√°...")
    st.write("""
    Voc√™ j√° se perguntou por que a Netflix parece estar cheia de dramas e document√°rios nos √∫ltimos anos? Ou por que alguns g√™neros sempre t√™m as notas mais altas? Eu tamb√©m. Foi da√≠ que surgiu a ideia de investigar os g√™neros mais populares e bem avaliados da plataforma. 
    
#### Objetivo
Neste projeto, meu objetivo foi analisar padr√µes de popularidade, qualidade e evolu√ß√£o temporal dos t√≠tulos da Netflix, a partir de dados abertos dispon√≠veis no Kaggle.
- **Dataset:** [Netflix Movies and TV Shows ‚Äì Kaggle](https://www.kaggle.com/datasets/shivamb/netflix-shows)

---

#### O que eu fiz?

**Limpeza e pr√©-processamento**:
Comecei tratando valores ausentes e padronizando os g√™neros que apareciam com muitas varia√ß√µes como 'Sci-Fi', 'Science Fiction' e 'Sci fi', e foram agrupados sob uma √∫nica categoria unificada.

**An√°lise explorat√≥ria**:
Depois, explorei os dados para entender padr√µes iniciais, como distribui√ß√µes de nota e quantidade de t√≠tulos por g√™nero, dura√ß√£o m√©dia, entre outros.

**Cria√ß√£o de visualiza√ß√µes**:
Utilizei gr√°ficos de barras, boxplots e contagens para revelar rela√ß√µes relevantes, por exemplo, a predomin√¢ncia de certos g√™neros ou a varia√ß√£o das avalia√ß√µes ao longo do tempo.

Desenvolvimento do dashboard com Streamlit:
Por fim, integrei as an√°lises em um dashboard interativo usando o Streamlit. Ele permite ao usu√°rio filtrar os dados por ano, tipo de produ√ß√£o (filme ou s√©rie), nota m√≠nima e g√™neros, facilitando a explora√ß√£o personalizada dos resultados.



---

#### üß≠ Como Navegar
- **Popularidade:** G√™neros com mais lan√ßamentos.
- **Distribui√ß√£o:** Notas do IMDb por tipo/g√™nero.
- **Evolu√ß√£o Temporal:** Lan√ßamentos por ano e g√™nero.
- **Dados Filtrados:** Tabela com os dados filtrados conforme os crit√©rios selecionados na barra lateral.

---

#### üí° Principais Insights
- O g√™nero **Drama** √© o mais comum.
- Document√°rios tendem a ter notas **IMDb mais altas**.


---
""")

def render_popularity_tab(df):
    """Renderiza a aba de Popularidade com gr√°ficos interativos."""
    st.subheader("Top G√™neros por Popularidade")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel para os filtros selecionados.")
        return

    genre_counts = df['genres'].str.split(',').explode().str.strip().value_counts().reset_index()
    genre_counts.columns = ['G√™nero', 'Contagem']
    genre_counts = genre_counts.sort_values('Contagem', ascending=False).head(10)
    
    # Come√ßo do Plotly
    fig = px.bar(
        genre_counts,
        x='Contagem',
        y='G√™nero',
        orientation='h',
        title="G√™neros Mais Frequentes",
        color='Contagem',
        color_continuous_scale=px.colors.sequential.Viridis,
        labels={'Contagem': 'N√∫mero de T√≠tulos', 'G√™nero': 'G√™nero'}
    )
    fig.update_layout(yaxis={'categoryorder':'total ascending'}) # Ordena o eixo Y
    st.plotly_chart(fig, use_container_width=True)

    st.markdown("### üìã Tabela: G√™neros Mais Frequentes")
    st.dataframe(genre_counts, use_container_width=True)

def render_distribution_tab(df):
    """Renderiza a aba de Distribui√ß√£o de Avalia√ß√µes."""
    st.subheader("Distribui√ß√£o de Avalia√ß√µes por G√™nero")
    
    if df.empty:
        st.warning("Nenhum dado dispon√≠vel para os filtros selecionados.")
        return
        
    current_genres = get_unique_genres(df)
    if not current_genres:
        st.info("Nenhum g√™nero para analisar com os filtros atuais.")
        return
        
    genre_to_analyze = st.selectbox("Selecione um g√™nero para detalhar:", options=current_genres)
    
    # SUGEST√ÉO: Usar Plotly tamb√©m para o histograma
    genre_df = df[df['genres'].str.contains(re.escape(genre_to_analyze), na=False)]
    fig = px.histogram(
        genre_df,
        x='imdbAverageRating',
        nbins=30,
        title=f"Distribui√ß√£o de Avalia√ß√µes - {genre_to_analyze}",
        labels={'imdbAverageRating': 'Avalia√ß√£o IMDb'},
        marginal="box" # Adiciona um boxplot para ver a distribui√ß√£o
    )
    st.plotly_chart(fig, use_container_width=True)
    
    # ... (resto da sua l√≥gica da aba de distribui√ß√£o)

def render_temporal_evolution_tab(df):
    """Renderiza a aba de Evolu√ß√£o Temporal."""
    st.subheader("Evolu√ß√£o Temporal das An√°lises")

    if df.empty:
        st.warning("Nenhum dado dispon√≠vel para os filtros selecionados.")
        return

    # Gr√°fico de linha - M√©dia de avalia√ß√µes por ano
    st.markdown("#### M√©dia de Avalia√ß√µes por Ano")
    avg_rating_by_year = df.groupby('releaseYear')['imdbAverageRating'].mean().reset_index()
    fig1 = px.line(
        avg_rating_by_year,
        x='releaseYear',
        y='imdbAverageRating',
        title="M√©dia de Avalia√ß√µes IMDb ao Longo dos Anos",
        labels={'releaseYear': 'Ano de Lan√ßamento', 'imdbAverageRating': 'Avalia√ß√£o M√©dia'}
    )
    fig1.update_traces(line_color='royalblue', line_width=2)
    st.plotly_chart(fig1, use_container_width=True)

    # Gr√°fico de barras - Quantidade de lan√ßamentos por ano
    st.markdown("#### Quantidade de Lan√ßamentos por Ano")
    year_counts = df['releaseYear'].value_counts().sort_index().reset_index()
    year_counts.columns = ['releaseYear', 'count']
    
    # SUGEST√ÉO: Usar um gr√°fico de √°rea para esta visualiza√ß√£o, fica √≥timo!
    fig2 = px.area(
        year_counts,
        x='releaseYear',
        y='count',
        title="N√∫mero de Lan√ßamentos por Ano",
        labels={'releaseYear': 'Ano de Lan√ßamento', 'count': 'Quantidade de T√≠tulos'}
    )
    st.plotly_chart(fig2, use_container_width=True)

def render_correlation_tab(df):
    """SUGEST√ÉO: Nova aba para an√°lise de correla√ß√£o."""
    st.subheader("An√°lise de Correla√ß√£o entre M√©tricas")
    st.markdown("""
    Esta an√°lise nos ajuda a entender como as vari√°veis num√©ricas se relacionam. 
    Por exemplo, uma correla√ß√£o positiva entre `imdbNumVotes` e `imdbAverageRating` 
    sugere que t√≠tulos com mais votos tendem a ter notas maiores.
    """)

    if df.empty:
        st.warning("Nenhum dado dispon√≠vel para os filtros selecionados.")
        return

    # Selecionar apenas colunas num√©ricas para a correla√ß√£o
    corr_df = df[['releaseYear', 'imdbAverageRating', 'imdbNumVotes']].copy()
    corr_matrix = corr_df.corr()

    # Criar o heatmap com Matplotlib e Seaborn
    fig, ax = plt.subplots(figsize=(8, 6))
    sns.heatmap(
        corr_matrix,
        annot=True,       # Mostra os valores de correla√ß√£o
        cmap='coolwarm',  # Paleta de cores
        fmt=".2f",        # Formata os n√∫meros para 2 casas decimais
        linewidths=.5,
        ax=ax
    )
    ax.set_title("Matriz de Correla√ß√£o")
    st.pyplot(fig)

def render_filtered_data_tab(df):
    """Renderiza a aba com a tabela de dados filtrados."""
    st.subheader("üìã Dados Filtrados")
    st.dataframe(
        df.sort_values('imdbAverageRating', ascending=False),
        height=400,
        use_container_width=True
    )
    
    # Converter para CSV para o bot√£o de download
    csv = df.to_csv(index=False).encode('utf-8')
    st.download_button(
        label="üì• Baixar Dados Filtrados (CSV)",
        data=csv,
        file_name='dados_filtrados.csv',
        mime='text/csv'
    )

def render_about_tab():
    """Renderiza a aba Sobre Mim."""
    st.markdown("#### üë©‚Äçüíª Sobre o Projeto e Sobre Mim")
    st.write("""
    Desenvolvido por mim, **Maria Rodrigues** üôÇ \n
    Sou estudante de Ci√™ncias Biol√≥gicas na UFRJ, com foco em Gen√©tica, e atuo como bolsista de Inicia√ß√£o Cient√≠fica em Bioinform√°tica. Curto muito tudo que envolve dados, tecnologia e ci√™ncia, e esse projeto faz parte do meu portf√≥lio na √°rea de **Data Science**, uma √°rea que venho explorando com bastante dedica√ß√£o.

    Se quiser trocar ideia ou acompanhar meus projetos, t√¥ por aqui:  
    üêô [GitHub](https://github.com/mulinco)  
    üíº [LinkedIn](https://www.linkedin.com/in/mariaclararodrigues3113)
    """)


# --- LAYOUT PRINCIPAL DO APP ---

st.title("üìä An√°lise de G√™neros de Filmes/S√©ries")

df = load_data()

if df is not None:
    # --- BARRA LATERAL DE FILTROS ---
    with st.sidebar:
        st.header("üîç Filtros Interativos")
        
        available_types = sorted(df['type'].unique())
        selected_type = st.selectbox("Selecione o tipo:", options=['Todos'] + available_types, index=0)
        
        min_year, max_year = int(df['releaseYear'].min()), int(df['releaseYear'].max())
        selected_years = st.slider("Selecione o intervalo de anos:", min_year, max_year, (min_year, max_year))
        
        unique_genres = get_unique_genres(df)
        selected_genres = st.multiselect("Selecione g√™neros:", options=unique_genres, default=['Action', 'Comedy', 'Drama'])
        
        min_rating, max_rating = float(df['imdbAverageRating'].min()), float(df['imdbAverageRating'].max())
        rating_range = st.slider("Filtrar por avalia√ß√£o IMDb:", min_rating, max_rating, (6.0, 9.0), step=0.1)

    # --- L√ìGICA DE FILTRAGEM ---
    # Come√ßa com uma c√≥pia do dataframe original
    filtered_df = df.copy()
    
    # Aplica os filtros sequencialmente
    filtered_df = filtered_df[
        (filtered_df['releaseYear'].between(*selected_years)) &
        (filtered_df['imdbAverageRating'].between(*rating_range))
    ]
    
    if selected_type != 'Todos':
        filtered_df = filtered_df[filtered_df['type'] == selected_type]
    
    if selected_genres:
        # L√≥gica de filtro "OU" para g√™neros: um t√≠tulo precisa ter pelo menos um dos g√™neros selecionados
        genre_pattern = '|'.join([re.escape(g) for g in selected_genres])
        filtered_df = filtered_df[filtered_df['genres'].str.contains(genre_pattern, na=False, regex=True)]

    # --- EXIBI√á√ÉO DAS M√âTRICAS GERAIS ---
    st.subheader("üìà M√©tricas Gerais (com base nos filtros)")
    if not filtered_df.empty:
        col1, col2, col3, col4, col5 = st.columns(5)
        with col1:
            st.metric("Total de T√≠tulos", f"{len(filtered_df):,}")
        with col2:
            st.metric("Nota M√©dia", f"{filtered_df['imdbAverageRating'].mean():.2f}")
        with col3:
            st.metric("Total de Votos", f"{filtered_df['imdbNumVotes'].sum():,}")
        with col4:
            st.metric("M√©dia de Votos/T√≠tulo", f"{filtered_df['imdbNumVotes'].mean():.0f}")
        with col5:
            st.metric("Desvio das Notas", f"{filtered_df['imdbAverageRating'].std():.2f}")
    else:
        st.info("Nenhum t√≠tulo encontrado com os filtros selecionados. Tente ampliar suas escolhas.")

    # --- ABAS DE NAVEGA√á√ÉO ---
    tab_intro, tab_pop, tab_dist, tab_evo, tab_corr, tab_data, tab_about = st.tabs([
        "üìö Introdu√ß√£o", "üìä Popularidade", "üé≠ Distribui√ß√£o", 
        "üìÖ Evolu√ß√£o Temporal", "üîó Correla√ß√µes", "üìé Dados Filtrados", "üë©‚Äçüíª Sobre Mim"
    ])
    
    with tab_intro:
        render_introduction_tab()
    with tab_pop:
        render_popularity_tab(filtered_df)
    with tab_dist:
        render_distribution_tab(filtered_df) 
    with tab_evo:
        render_temporal_evolution_tab(filtered_df)
    with tab_corr:
        render_correlation_tab(filtered_df)
    with tab_data:
        render_filtered_data_tab(filtered_df)
    with tab_about:
        render_about_tab()
        
else:
    st.warning("N√£o foi poss√≠vel carregar os dados. O aplicativo n√£o pode ser exibido.")

